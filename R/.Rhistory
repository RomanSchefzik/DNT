})
observe({
x <- input$method2
if(x == "EBICglasso"){
updateSelectInput(session, "adj.method2",
label = paste("Select input label"),
choices = list("pearson", "kendall", "spearman"),
selected = "pearson")
}else{
updateSelectInput(session, "adj.method2",
label = paste("Select input label"),
choices = list("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none"),
selected = "holm")
}
})
observe({
x <- input$method3
if(x == "EBICglasso"){
updateSelectInput(session, "adj.method3",
label = paste("Select input label"),
choices = list("pearson", "kendall", "spearman"),
selected = "pearson")
}else{
updateSelectInput(session, "adj.method3",
label = paste("Select input label"),
choices = list("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none"),
selected = "holm")
}
})
observe({
x <- input$method5
if(x == "EBICglasso"){
updateSelectInput(session, "adj.method5",
label = paste("Select input label"),
choices = list("pearson", "kendall", "spearman"),
selected = "pearson")
}else{
updateSelectInput(session, "adj.method5",
label = paste("Select input label"),
choices = list("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none"),
selected = "holm")
}
})
output$plot1 <- renderPlot({
graph.plot(A = x1, B = x2, methodlist = list(input$method, input$adj.method, input$tun.ebic), thresh = 0.05, cluster = TRUE, negcol = input$negcol, poscol = input$poscol, multiplier = input$multiplier, curved = input$curve, layout = layout.func(input$layout), vSize = input$vSize, tSize = input$tSize)
})
output$plot2 <- renderPlot({
graph.plot(A = x1, B = x2, methodlist = list(input$method2, input$adj.method2, input$tun.ebic2), admission = TRUE, event = FALSE, thresh = 0.05, cluster = TRUE, negcol = input$negcol2, poscol = input$poscol2, multiplier = input$multiplier2, curved = input$curve2, layout = layout.func(input$layout2), vSize = input$vSize2, tSize = input$tSize2)
})
output$plot3 <- renderPlot({
graph.plot(A = x1, B = x2, methodlist = list(input$method3, input$adj.method3, input$tun.ebic3), admission = FALSE, event = TRUE, thresh = 0.05, cluster = TRUE, negcol = input$negcol3, poscol = input$poscol3, multiplier = input$multiplier3, curved = input$curve3, layout = layout.func(input$layout3), vSize = input$vSize3, tSize = input$tSize3)
})
output$plot5 <- renderPlot({
graph.plot(A = x1, B = x2, methodlist = list(input$method5, input$adj.method5, input$tun.ebic5), thresh = 0.05, cluster = FALSE, negcol = input$negcol5, poscol = input$poscol5, multiplier = input$multiplier5,  curved = input$curve5, layout = layout.func(input$layout5), vSize = input$vSize5, tSize = input$tSize5)
})
}
shinyApp(ui1, server1)
?shinyApp
devtools::document()
ui <- basicPage(
title = "DNT",
navbarPage(
"Differential network test",
#1. Panel: Comparison -----------------------
tabPanel(
"Comparison",
fluidRow(
column(3,
sliderInput("vSize", "Vertice Size", min=8, max=50, value=16),
sliderInput("tSize", "Text Size", min=0.4, max=2.5, value=0.8),
),
column(3,
textInput("negcol", "Color of negative edges", value = "blue"),
textInput("poscol", "Color of positive edges", value = "red"),
numericInput("multiplier", "Multiplier with edge weight", value=4)
),
column(3,
selectInput("layout", "Layout", choices=list("layout.auto", "layout.circle", "layout.davidson.harel", "layout.drl", "layout.fruchterman.reingold", "layout.fruchterman.reingold.grid", "layout.gem", "layout.graphopt", "layout.grid", "layout.kamada.kawai", "layout.lgl", "layout.mds", "layout.reingold.tilford", "layout.spring", "layout.star", "layout.svd")),
selectInput("curve", "Edge curved", choices=list(TRUE, FALSE))
),
column(3,
selectInput("method", "Method to create adjacency matrix", choices = list("Spearman","PCSpearman","Spearman.adj","PCSpearman.adj", "DistCorr", "DistCorr.adj", "EBICglasso")),
selectInput("adj.method", "Method 2", choices = list("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none")),
numericInput("tun.ebic", "Number for EBICglasso",min = 0,max = 1, step = 0.01, value = 0)#,Distcorr = list("DistCorr"))),
)
),
mainPanel(width = 12,plotOutput("plot1"))
),
#2. Survivors Admission -----------------------
tabPanel(
"Survivors Admission",
fluidRow(
column(3,
sliderInput("vSize2", "Vertice Size", min=8, max=50, value=16),
sliderInput("tSize2", "Text Size", min=0.4, max=2.5, value=0.8),
),
column(3,
textInput("negcol2", "Color of negative edges", value = "blue"),
textInput("poscol2", "Color of positive edges", value = "red"),
numericInput("multiplier2", "Multiplier with edge weight", value=4)
),
column(3,
selectInput("layout2", "Layout", choices=list("layout.auto", "layout.circle", "layout.davidson.harel", "layout.drl", "layout.fruchterman.reingold", "layout.fruchterman.reingold.grid", "layout.gem", "layout.graphopt", "layout.grid", "layout.kamada.kawai", "layout.lgl", "layout.mds", "layout.reingold.tilford", "layout.spring", "layout.star", "layout.svd")),
selectInput("curve2", "Edge curved", choices=list(TRUE, FALSE))
),
column(3,
selectInput("method2", "Method to create adjacency matrix", choices = list("Spearman","PCSpearman","Spearman.adj","PCSpearman.adj", "DistCorr", "DistCorr.adj", "EBICglasso")),
selectInput("adj.method2", "Method 2", choices = list("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none")),
numericInput("tun.ebic2", "Number for EBICglasso",min = 0,max = 1, step = 0.01, value = 0)#,Distcorr = list("DistCorr"))),
)
),
mainPanel(width = 12, plotOutput("plot2"))
),
#3. Panel: Survivors Event -----------------------
tabPanel(
"Survivors Event",
fluidRow(
column(3,
sliderInput("vSize3", "Vertice Size", min=8, max=50, value=16),
sliderInput("tSize3", "Text Size", min=0.4, max=2.5, value=0.8),
),
column(3,
textInput("negcol3", "Color of negative edges", value = "blue"),
textInput("poscol3", "Color of positive edges", value = "red"),
numericInput("multiplier3", "Multiplier with edge weight", value=4)
),
column(3,
selectInput("layout3", "Layout", choices=list("layout.auto", "layout.circle", "layout.davidson.harel", "layout.drl", "layout.fruchterman.reingold", "layout.fruchterman.reingold.grid", "layout.gem", "layout.graphopt", "layout.grid", "layout.kamada.kawai", "layout.lgl", "layout.mds", "layout.reingold.tilford", "layout.spring", "layout.star", "layout.svd")),
selectInput("curve3", "Edge curved", choices=list(TRUE, FALSE))
),
column(3,
selectInput("method3", "Method to create adjacency matrix", choices = list("Spearman","PCSpearman","Spearman.adj","PCSpearman.adj", "DistCorr", "DistCorr.adj", "EBICglasso")),
selectInput("adj.method3", "Method 2", choices = list("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none")),
numericInput("tun.ebic3", "Number for EBICglasso",min = 0,max = 1, step = 0.01, value = 0)#,Distcorr = list("DistCorr"))),
)
),
mainPanel(width = 12, plotOutput("plot3"))
),
#4. Panel: Without Clusters -----------------------
tabPanel(
"Without Clusters",
fluidRow(
column(3,
sliderInput("vSize5", "Vertice Size", min=8, max=50, value=16),
sliderInput("tSize5", "Text Size", min=0.4, max=2.5, value=0.8),
),
column(3,
textInput("negcol5", "Color of negative edges", value = "blue"),
textInput("poscol5", "Color of positive edges", value = "red"),
numericInput("multiplier5", "Multiplier with edge weight", value=4)
),
column(3,
selectInput("layout5", "Layout", choices=list("layout.auto", "layout.circle", "layout.davidson.harel", "layout.drl", "layout.fruchterman.reingold", "layout.fruchterman.reingold.grid", "layout.gem", "layout.graphopt", "layout.grid", "layout.kamada.kawai", "layout.lgl", "layout.mds", "layout.reingold.tilford", "layout.spring", "layout.star", "layout.svd")),
selectInput("curve5", "Edge curved", choices=list(TRUE, FALSE))
),
column(3,
selectInput("method5", "Method to create adjacency matrix", choices = list("Spearman","PCSpearman","Spearman.adj","PCSpearman.adj", "DistCorr", "DistCorr.adj", "EBICglasso")),
selectInput("adj.method5", "Method 2", choices = list("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none")),
numericInput("tun.ebic5", "Number for EBICglasso",min = 0, step = 0.3, value = 0)#,Distcorr = list("DistCorr"))),
)
),
mainPanel(width = 12,plotOutput("plot5"))
)
)
)
devtools::document()
devtools::load_all()
?layout.func
?server
shinyApp(ui, server)
ui <- basicPage(
title = "DNT",
navbarPage(
"Differential network test",
#1. Panel: Comparison -----------------------
tabPanel(
"Comparison",
fluidRow(
column(3,
sliderInput("vSize", "Vertice Size", min=8, max=50, value=16),
sliderInput("tSize", "Text Size", min=0.4, max=2.5, value=0.8),
),
column(3,
textInput("negcol", "Color of negative edges", value = "blue"),
textInput("poscol", "Color of positive edges", value = "red"),
numericInput("multiplier", "Multiplier with edge weight", value=4)
),
column(3,
selectInput("layout", "Layout", choices=list("layout.auto", "layout.circle", "layout.davidson.harel", "layout.drl", "layout.fruchterman.reingold", "layout.fruchterman.reingold.grid", "layout.gem", "layout.graphopt", "layout.grid", "layout.kamada.kawai", "layout.lgl", "layout.mds", "layout.reingold.tilford", "layout.spring", "layout.star", "layout.svd")),
selectInput("curve", "Edge curved", choices=list(TRUE, FALSE))
),
column(3,
selectInput("method", "Method to create adjacency matrix", choices = list("Spearman","PCSpearman","Spearman.adj","PCSpearman.adj", "DistCorr", "DistCorr.adj", "EBICglasso")),
selectInput("adj.method", "Method 2", choices = list("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none")),
numericInput("tun.ebic", "Number for EBICglasso",min = 0,max = 1, step = 0.01, value = 0)#,Distcorr = list("DistCorr"))),
)
),
mainPanel(width = 12,plotOutput("plot1"))
),
#2. Survivors Admission -----------------------
tabPanel(
"Survivors Admission",
fluidRow(
column(3,
sliderInput("vSize2", "Vertice Size", min=8, max=50, value=16),
sliderInput("tSize2", "Text Size", min=0.4, max=2.5, value=0.8),
),
column(3,
textInput("negcol2", "Color of negative edges", value = "blue"),
textInput("poscol2", "Color of positive edges", value = "red"),
numericInput("multiplier2", "Multiplier with edge weight", value=4)
),
column(3,
selectInput("layout2", "Layout", choices=list("layout.auto", "layout.circle", "layout.davidson.harel", "layout.drl", "layout.fruchterman.reingold", "layout.fruchterman.reingold.grid", "layout.gem", "layout.graphopt", "layout.grid", "layout.kamada.kawai", "layout.lgl", "layout.mds", "layout.reingold.tilford", "layout.spring", "layout.star", "layout.svd")),
selectInput("curve2", "Edge curved", choices=list(TRUE, FALSE))
),
column(3,
selectInput("method2", "Method to create adjacency matrix", choices = list("Spearman","PCSpearman","Spearman.adj","PCSpearman.adj", "DistCorr", "DistCorr.adj", "EBICglasso")),
selectInput("adj.method2", "Method 2", choices = list("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none")),
numericInput("tun.ebic2", "Number for EBICglasso",min = 0,max = 1, step = 0.01, value = 0)#,Distcorr = list("DistCorr"))),
)
),
mainPanel(width = 12, plotOutput("plot2"))
),
#3. Panel: Survivors Event -----------------------
tabPanel(
"Survivors Event",
fluidRow(
column(3,
sliderInput("vSize3", "Vertice Size", min=8, max=50, value=16),
sliderInput("tSize3", "Text Size", min=0.4, max=2.5, value=0.8),
),
column(3,
textInput("negcol3", "Color of negative edges", value = "blue"),
textInput("poscol3", "Color of positive edges", value = "red"),
numericInput("multiplier3", "Multiplier with edge weight", value=4)
),
column(3,
selectInput("layout3", "Layout", choices=list("layout.auto", "layout.circle", "layout.davidson.harel", "layout.drl", "layout.fruchterman.reingold", "layout.fruchterman.reingold.grid", "layout.gem", "layout.graphopt", "layout.grid", "layout.kamada.kawai", "layout.lgl", "layout.mds", "layout.reingold.tilford", "layout.spring", "layout.star", "layout.svd")),
selectInput("curve3", "Edge curved", choices=list(TRUE, FALSE))
),
column(3,
selectInput("method3", "Method to create adjacency matrix", choices = list("Spearman","PCSpearman","Spearman.adj","PCSpearman.adj", "DistCorr", "DistCorr.adj", "EBICglasso")),
selectInput("adj.method3", "Method 2", choices = list("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none")),
numericInput("tun.ebic3", "Number for EBICglasso",min = 0,max = 1, step = 0.01, value = 0)#,Distcorr = list("DistCorr"))),
)
),
mainPanel(width = 12, plotOutput("plot3"))
),
#4. Panel: Without Clusters -----------------------
tabPanel(
"Without Clusters",
fluidRow(
column(3,
sliderInput("vSize5", "Vertice Size", min=8, max=50, value=16),
sliderInput("tSize5", "Text Size", min=0.4, max=2.5, value=0.8),
),
column(3,
textInput("negcol5", "Color of negative edges", value = "blue"),
textInput("poscol5", "Color of positive edges", value = "red"),
numericInput("multiplier5", "Multiplier with edge weight", value=4)
),
column(3,
selectInput("layout5", "Layout", choices=list("layout.auto", "layout.circle", "layout.davidson.harel", "layout.drl", "layout.fruchterman.reingold", "layout.fruchterman.reingold.grid", "layout.gem", "layout.graphopt", "layout.grid", "layout.kamada.kawai", "layout.lgl", "layout.mds", "layout.reingold.tilford", "layout.spring", "layout.star", "layout.svd")),
selectInput("curve5", "Edge curved", choices=list(TRUE, FALSE))
),
column(3,
selectInput("method5", "Method to create adjacency matrix", choices = list("Spearman","PCSpearman","Spearman.adj","PCSpearman.adj", "DistCorr", "DistCorr.adj", "EBICglasso")),
selectInput("adj.method5", "Method 2", choices = list("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none")),
numericInput("tun.ebic5", "Number for EBICglasso",min = 0, step = 0.3, value = 0)#,Distcorr = list("DistCorr"))),
)
),
mainPanel(width = 12,plotOutput("plot5"))
)
)
)
#' Server
#' @description
#' Server for the ShinyApp.
#' @export
#'
server <- function(input,output, session){
observe({
x <- input$method
if(x == "EBICglasso"){
updateSelectInput(session, "adj.method",
label = paste("Select input label"),
choices = list("pearson", "kendall", "spearman"),
selected = "pearson")
}else{
updateSelectInput(session, "adj.method",
label = paste("Select input label"),
choices = list("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none"),
selected = "holm")
}
})
observe({
x <- input$method2
if(x == "EBICglasso"){
updateSelectInput(session, "adj.method2",
label = paste("Select input label"),
choices = list("pearson", "kendall", "spearman"),
selected = "pearson")
}else{
updateSelectInput(session, "adj.method2",
label = paste("Select input label"),
choices = list("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none"),
selected = "holm")
}
})
observe({
x <- input$method3
if(x == "EBICglasso"){
updateSelectInput(session, "adj.method3",
label = paste("Select input label"),
choices = list("pearson", "kendall", "spearman"),
selected = "pearson")
}else{
updateSelectInput(session, "adj.method3",
label = paste("Select input label"),
choices = list("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none"),
selected = "holm")
}
})
observe({
x <- input$method5
if(x == "EBICglasso"){
updateSelectInput(session, "adj.method5",
label = paste("Select input label"),
choices = list("pearson", "kendall", "spearman"),
selected = "pearson")
}else{
updateSelectInput(session, "adj.method5",
label = paste("Select input label"),
choices = list("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none"),
selected = "holm")
}
})
output$plot1 <- renderPlot({
graph.plot(A = x1, B = x2, methodlist = list(input$method, input$adj.method, input$tun.ebic), thresh = 0.05, cluster = TRUE, negcol = input$negcol, poscol = input$poscol, multiplier = input$multiplier, curved = input$curve, layout = layout.func(input$layout), vSize = input$vSize, tSize = input$tSize)
})
output$plot2 <- renderPlot({
graph.plot(A = x1, B = x2, methodlist = list(input$method2, input$adj.method2, input$tun.ebic2), admission = TRUE, event = FALSE, thresh = 0.05, cluster = TRUE, negcol = input$negcol2, poscol = input$poscol2, multiplier = input$multiplier2, curved = input$curve2, layout = layout.func(input$layout2), vSize = input$vSize2, tSize = input$tSize2)
})
output$plot3 <- renderPlot({
graph.plot(A = x1, B = x2, methodlist = list(input$method3, input$adj.method3, input$tun.ebic3), admission = FALSE, event = TRUE, thresh = 0.05, cluster = TRUE, negcol = input$negcol3, poscol = input$poscol3, multiplier = input$multiplier3, curved = input$curve3, layout = layout.func(input$layout3), vSize = input$vSize3, tSize = input$tSize3)
})
output$plot5 <- renderPlot({
graph.plot(A = x1, B = x2, methodlist = list(input$method5, input$adj.method5, input$tun.ebic5), thresh = 0.05, cluster = FALSE, negcol = input$negcol5, poscol = input$poscol5, multiplier = input$multiplier5,  curved = input$curve5, layout = layout.func(input$layout5), vSize = input$vSize5, tSize = input$tSize5)
})
}
shinyApp(ui, server)
#' @param vSize the size of the vertices.
#' @param tSize the size of the names inside the vertices.
#' @details
#' The graphs are plotted with the same layout and other plot characteristics so that the two graphs are easy to
#' compare. The left network is the Survivors Admission and the right one the Survivor Event.
#' @return
#' @examples
#' graph.plot(x1,x2, list("Spearman), caption = "Spearman", directory)
#' @export
#'
graph.plot <- function(A, B, methodlist, thresh = 0.05, admission = TRUE, event = TRUE, cluster = TRUE, negcol = "red", poscol= "blue",multiplier = 4, curved = TRUE, layout = layout.fruchterman.reingold, vSize = 16, tSize = 0.8){
stopifnot("cluster needs to be boolean" = cluster==TRUE || cluster==FALSE,
"negcol and poscol need to be strings" = class(negcol)=="character" && class(poscol)=="character",
"multiplier needs to be a positive number" = (class(multiplier)=="numeric"||class(multiplier)=="integer") && multiplier>0,
"admission and event needs to be boolean" = class(admission)=="logical" && class(event)=="logical",
"layout needs to be a layout-function" = class(layout)=="function",
"vSize and tSize need to be positive numbers" = (class(vSize)=="numeric" || class(vSize)=="integer") &&
(class(tSize)=="numeric" || class(tSize)=="integer"),
"vSize needs to be 20 times bigger than tSize to have a good relation between the names and the vertices" = tSize*20<=vSize
)
g1 <- create.Igraphclustering(A, methodlist, thresh)
g2 <- create.Igraphclustering(B, methodlist, thresh)
if(is.null(g1[[1]]) == FALSE){
E(g1[[2]])[which(E(g1[[2]])$weight<0)]$color <- negcol
E(g1[[2]])[which(E(g1[[2]])$weight>0)]$color <- poscol
E(g1[[2]])$weight <- abs(E(g1[[2]])$weight)
}
if(is.null(g2[[1]]) == FALSE){
E(g2[[2]])[which(E(g2[[2]])$weight<0)]$color <- negcol
E(g2[[2]])[which(E(g2[[2]])$weight>0)]$color <- poscol
E(g2[[2]])$weight <- abs(E(g2[[2]])$weight)
}
par(mfrow=c(1,2),oma=c(0,0,2,0))
if(cluster == TRUE){
if(admission == TRUE && is.null(g1[[1]]) == FALSE){
plot(
g1[[1]], g1[[2]],
layout= layout,
edge.curved=curved,
vertex.size=vSize,
#vertex.label.dist=-0.5,
#vertex.label.color="red",
#asp=1,
vertex.label.cex=tSize,
edge.width=E(g1[[2]])$weight*multiplier,
edge.color = E(g1[[2]])$color,
edge.arrow.mode=FALSE,
main="Survivors Admission")
}else if(admission == TRUE){
plot(
g1[[2]],
#xlab = "For the Survivors Admission there are no correlation so the graph is empty (without edges)",
layout=layout,
edge.curved=curved,
vertex.size=vSize,
#vertex.label.dist=-0.5,
#vertex.label.color=E(g1[[2]])$color,
#asp=FALSE,
vertex.label.cex=tSize,
edge.width=E(g1[[2]])$weight*multiplier,
edge.arrow.mode=FALSE,
main="Survivors Admission")
mtext("No correlations!", side = 1)
}
if(event == TRUE && is.null(g2[[1]]) == FALSE){
plot(
g2[[1]], g2[[2]],
layout=layout,
edge.curved=curved,
vertex.size=vSize,
#vertex.label.dist=-0.5,
#vertex.label.color="black",
#asp=FALSE,
vertex.label.cex=tSize,
edge.width=E(g2[[2]])$weight*multiplier,
edge.color = E(g2[[2]])$color,
edge.arrow.mode=FALSE,
main="Survivors Event")
}else if(event == TRUE){
plot(
g2[[2]],
#xlab = "For the Survivors Event there are no correlation so the graph is empty (without edges)",
layout=layout,
edge.curved=curved,
vertex.size=vSize,
#vertex.label.dist=-0.5,
#vertex.label.color="black",
#asp=FALSE,
vertex.label.cex=tSize,
edge.width=E(g2[[2]])$weight*multiplier,
edge.arrow.mode=FALSE,
main="Survivors Event")
mtext("No correlations!", side = 1)
}
}else{
if(admission == TRUE){
plot(
g1[[2]],
layout=layout,
edge.curved=curved,
vertex.size=vSize,
#vertex.label.dist=-0.5,
#vertex.label.color=E(g1[[2]])$color,
#asp=FALSE,
vertex.label.cex=tSize,
edge.width=E(g1[[2]])$weight*multiplier,
edge.arrow.mode=FALSE,
main="Survivors Admission")
}
if(event == TRUE){
plot(
g2[[2]],
layout=layout,
edge.curved=curved,
vertex.size=vSize,
#vertex.label.dist=-0.5,
#vertex.label.color="black",
#asp=FALSE,
vertex.label.cex=tSize,
edge.width=E(g2[[2]])$weight*multiplier,
edge.arrow.mode=FALSE,
main="Survivors Event")
}
}
caption <- methodlist[[1]]
mtext(caption,outer=TRUE,cex=1.5)
}
#' @param methodlist the methods used to create the adjacency matrix.
#' @param thresh the threshold under which the values of the correlations are relevant.
#' @details
#' First the method creates the adjacency matrix out of the matrix A and after that the adjacency matrix can be
#' used to create the Igraph and its clusters.
#' @return The method returns a list with the Igraph from A and its clusters.
#' @example
#' create.Igraphclustering(x1, list("Spearman"))
#' @export
#'
create.Igraphclustering <- function(A, methodlist, thresh = 0.05){
cm.x1 <- create.adjacency.matrix(A, methodlist, thresh)
if(all(cm.x1==0) == TRUE){
numbervertices <- length(A)
g.x1 <- make_empty_graph(n = numbervertices)
V(g.x1)$name <- names(A)
g.clustering.x1 <- NULL
}
else{
# Make an Igraph object from this matrix:
g.x1<-graph.adjacency(cm.x1,weighted=TRUE, mode="undirected", diag=FALSE)
# Simplfy the adjacency object
g.x1<-simplify(g.x1, remove.multiple=TRUE, remove.loops=TRUE)
# let's see if we have communities here using the
# Grivan-Newman algorithm
# 1st we calculate the edge betweenness, merges, etc...
g.communities.x1 <- edge.betweenness.community(g.x1, weights=NULL, directed=FALSE)
g.clustering.x1 <- make_clusters(g.x1, membership=g.communities.x1$membership)
V(g.x1)$color <- g.communities.x1$membership
}
list(g.clustering.x1, g.x1)
}
shinyApp(ui, server)
