infectedpoints >= 0,
days > 0,
border > 0,
steplength > 0,
transmissiondistance > 0,
p > 0 && p <= 1,
infectiondays > 0,
ptest > 0 && ptest <= 1,
timetoquarantine >= 0,
quarantinelength > 0,
quarantinesteps > 0,
sidelengthquarantinesquare != 0,
immunedays >= 0,
p_mvt_to_center <= 1,
p_mvt_to_center >= 0,
-border < marketplace_x,
marketplace_x < border,
-border < marketplace_y,
marketplace_y < border,
travelspeed >= 0,
travelspeed <= (border/3),
travelfrequency >= 0,
"Steplength must be at least 5 times smaller than border" = steplength*5 <= abs(border),
"Sidelength of the quarantine square cannot be larger than one fifth of the border length" =  5 * sidelengthquarantinesquare<= border,
"Steplength in quarantine must be at least 2 times smaller than Sidelength of the quarantine square" = quarantinesteps *2 <= sidelengthquarantinesquare)
### The probability for every person that he/she gets himself/herself tested when he/she is sick and that the test really is positive when it should be
ptested <- lapply(rep(ptest, (infectedpoints+healthypoints)), wahrscheinlichkeit)
### Create two list of tibbles with random movement
if(infectedpoints > 0){
listoftibs1 <- tiberzeugen(infectedpoints, days, steplength, border)
# Set all tibbles in first list to infected, all in second to not infected, and the other paramteres corresponding to this
for(i in 1:length(listoftibs1)){
listoftibs1[[i]] <- tibble(listoftibs1[[i]], infected = "not infected",immune = FALSE, quarantine = FALSE, gets_tested = 0, trip_to_market = FALSE)
listoftibs1[[i]]$infected[1:min(infectiondays,days)] <- "infected"
listoftibs1[[i]]$gets_tested <- ptested[[i]]
listoftibs1[[i]]$immune[1:min((infectiondays+immunedays), days)] <- TRUE
listoftibs1[[i]]$counted <- TRUE
}
}
if(healthypoints > 0){
listoftibs2 <- tiberzeugen(healthypoints, days, steplength, border)
for(i in 1:length(listoftibs2)){
listoftibs2[[i]] <- tibble(listoftibs2[[i]], infected = "not infected",immune = FALSE, quarantine = FALSE, gets_tested = 0, trip_to_market = FALSE)
listoftibs2[[i]]$gets_tested <- ptested[[infectedpoints+i]]
listoftibs2[[i]]$counted <- FALSE
}
}
### Attribute to count how many of the people got infected at least once
gesamtinfiziert <- infectedpoints
# Connect both lists: from now on it does not matter if they were infected in the beginning, what matters is the current value
if(healthypoints > 0 && infectedpoints > 0) listoftibs <- c(listoftibs1, listoftibs2)
if(healthypoints <= 0 && infectedpoints > 0) listoftibs <- listoftibs1
if(healthypoints > 0 && infectedpoints <= 0) listoftibs <- listoftibs2
if(mvt_to_center == T){
for(i in 1:length(listoftibs)){
wkeit <- wahrscheinlichkeit(p_mvt_to_center)
if(wkeit == TRUE){
listoftibs[[i]] <- bewegungzumzentrum(listoftibs[[i]], zentrum_x = marketplace_x, zentrum_y = marketplace_y, speed = travelspeed, frequenz_besuche = travelfrequency)
}
}
}
# Go through every step of the time
#days <- length(listoftibs1[[1]]$x)
for(i in 1:(days-1)){
for(m in 1:length(listoftibs)){
for(n in 1:length(listoftibs)){
#First get the infected ones in quarantine
if(listoftibs[[n]]$infected[i] == "infected" && all(listoftibs[[n]]$quarantine[i:min(i+timetoquarantine,days)] == FALSE) == TRUE && quarantine == TRUE && listoftibs[[n]]$gets_tested[1] == TRUE){
quarantineborder <- border+sidelengthquarantinesquare
end <- min(i+timetoquarantine+quarantinelength-1, days)
if(i+timetoquarantine+quarantinelength<days){
laenge <- quarantinelength
}else{
laenge <- days-(i+timetoquarantine)
}
if(laenge>1){
move <- bewegunginquarantine(laenge, steplength = quarantinesteps, border = quarantineborder, bigsquare = border)
listoftibs[[n]]$x[min((i+timetoquarantine), days):end] <- unlist(move[[1]])
listoftibs[[n]]$y[min((i+timetoquarantine), days):end] <- unlist(move[[2]])
listoftibs[[n]]$quarantine[min((i+timetoquarantine), days):end] <- TRUE
}
}
#Check if one could infect the other; through the for-loop with the parameter i we are in the same time for both tibbles
if(n != m && listoftibs[[n]]$quarantine[i] == FALSE && listoftibs[[m]]$quarantine[i] == FALSE){
if((listoftibs[[m]]$infected[i] == "infected" && listoftibs[[n]]$infected[i] == "not infected")| (listoftibs[[n]]$infected[i] == "infected"&& listoftibs[[m]]$infected[i] == "not infected")){
#Claculate the distance between the points
diffx <- listoftibs[[m]]$x[i]-listoftibs[[n]]$x[i]
diffy <- listoftibs[[m]]$y[i]-listoftibs[[n]]$y[i]
a <- sqrt(diffx^2+diffy^2)
if(a < transmissiondistance){
#Probability that the infected one will infect the healthy one
p <- wahrscheinlichkeit(p)
if(p == TRUE){
if(listoftibs[[m]]$infected[i] == "infected" && listoftibs[[n]]$infected[i] == "not infected" && listoftibs[[n]]$immune[i] == "FALSE"){
listoftibs[[n]]$infected[min((i+1),days):min((i+1+infectiondays),days)] <- "infected"
listoftibs[[n]]$immune[min((i+1), days):min((i+1+infectiondays+immunedays), days)] <- TRUE
if(listoftibs[[n]]$counted[i] == "FALSE"){
gesamtinfiziert <- gesamtinfiziert+1
listoftibs[[n]]$counted[i:days] <- TRUE
}
}
if(listoftibs[[n]]$infected[i] == "infected" && listoftibs[[m]]$infected[i] == "not infected" && listoftibs[[m]]$immune[i] == "FALSE"){
listoftibs[[m]]$infected[min((i+1),days):min((i+1+infectiondays), days)] <- "infected"
listoftibs[[m]]$immune[min((i+1),days):min((i+1+infectiondays+immunedays),days)] <- TRUE
if(listoftibs[[m]]$counted[i] == "FALSE"){
gesamtinfiziert <- gesamtinfiziert+1
listoftibs[[m]]$counted[i:days] <- TRUE
}
}
}
}
}
}
}
}
}
aktuellinfiziert <- rep(0, days)
aktuellinfiziert[1] <- infectedpoints
for(i in 2:days){
aktuellinfiziert[i] <- aktuellinfiziert[i-1]
for(m in 1:length(listoftibs)){
if(listoftibs[[m]]$infected[i-1] == "infected" && listoftibs[[m]]$infected[i] == "not infected")
{
aktuellinfiziert[i] <- aktuellinfiziert[i]-1
}
if(listoftibs[[m]]$infected[i-1] == "not infected" && listoftibs[[m]]$infected[i] == "infected"){
aktuellinfiziert[i] <- aktuellinfiziert[i]+1
}
}
}
aktinf <- tibble("time" = 1:days, "current_infected" = aktuellinfiziert)
listoftibs <- c(listoftibs, "gesamtinfiziert" = gesamtinfiziert, "border" = border)
listoftibs[[length(listoftibs)+1]] <- aktinf
return(listoftibs)
}
erg <- individualSimulation(quarantine = TRUE)
erg[[1]]
erg <- individualSimulation(quarantine = TRUE, timetoquarantine = 10, quarantinelength = 2)
erg[[1]]
erg[[2]]
print(erg[[2]], n = 13)
print(erg[[4]], n = 13)
print(erg[[5]], n = 13)
erg <- individualSimulation(quarantine = TRUE, timetoquarantine = 10, quarantinelength = 1)
print(erg[[1]], n = 13)
#'@param mvt_to_center Boolean. If set to T, the movement to a marketplace takes place.
#'@param p_mvt_to_center The probability that a point is able to go to the marketplace.
#'@param marketplace_x x coordinate of the marketplace.
#'@param marketplace_y y coordinate of the marketplace.
#'@param travelspeed speed of the movement in direction of the marketplace.
#'@param travelfrequency average frequency of a trip to the marketplace of a point which is not already in movement.
#'@return A list of tibbles that contains the movement and all other attributes of the points.
#'@examples individualSimulation()
#'@examples individualSimulation(steplength = 0.15, transmissiondistance = 0.2, quarantine = FALSE)
#'@export
individualSimulation <- function(healthypoints = 30, infectedpoints = 30, days = 50, border = 1, steplength = 0.05,transmissiondistance = 0.1, p = 0.8, infectiondays = 8, quarantine = FALSE, ptest = 0.8 , timetoquarantine = 3, quarantinelength = 6, quarantinesteps = 0.02, sidelengthquarantinesquare = 0.2, immunedays = 5, mvt_to_center = FALSE, p_mvt_to_center = 0.5, marketplace_x = 0, marketplace_y = 0, travelspeed = 0.02, travelfrequency = 10){
if(quarantine == FALSE){
sidelengthquarantinesquare <- abs(border)/5
quarantinesteps <- sidelengthquarantinesquare/2
}
stopifnot(class(healthypoints) == "numeric" || class(healthypoints) == "integer",
class(infectedpoints) == "numeric" || class(infectedpoints) == "integer",
class(days) == "numeric" || class(days) == "integer",
class(border) == "numeric" || class(border) == "integer",
class(steplength) == "numeric" || class(steplength) == "integer",
class(transmissiondistance) == "numeric" || class(transmissiondistance) == "integer",
class(p) == "numeric" || class(p) == "integer",
class(infectiondays) == "numeric" || class(infectiondays) == "integer",
class(quarantine) == "logical",
class(ptest) == "numeric" || class(ptest) == "integer",
class(timetoquarantine) == "numeric" || class(timetoquarantine) == "integer",
class(quarantinelength) == "numeric" || class(quarantinelength) == "integer",
class(quarantinesteps) == "numeric" || class(quarantinesteps) == "integer",
class(sidelengthquarantinesquare) == "numeric" || class(sidelengthquarantinesquare) == "integer",
class(immunedays) == "numeric" || class(immunedays) == "integer",
class(mvt_to_center) == "logical",
class(p_mvt_to_center) == "numeric" || class(p_mvt_to_center) == "integer",
class(marketplace_x) == "numeric" || class(marketplace_x) == "integer",
class(marketplace_y) == "numeric" || class(marketplace_y) == "integer",
class(travelspeed) == "numeric" || class(travelspeed) == "integer",
class(travelfrequency) == "numeric" || class(travelfrequency) == "integer")
stopifnot(length(healthypoints) == 1,
length(infectedpoints) == 1,
length(days) == 1,
length(border) == 1,
length(steplength) == 1,
length(transmissiondistance) == 1,
length(p) == 1,
length(infectiondays) == 1,
length(quarantine) == 1,
length(ptest) == 1,
length(timetoquarantine) == 1,
length(quarantinelength) == 1,
length(quarantinesteps) == 1,
length(sidelengthquarantinesquare) == 1,
length(immunedays) == 1,
length(mvt_to_center) == 1,
length(p_mvt_to_center) == 1,
length(marketplace_x) == 1,
length(marketplace_y) == 1,
length(travelspeed) == 1,
length(travelfrequency) == 1)
stopifnot(healthypoints%%1 == 0,
healthypoints >= 0,
infectedpoints+healthypoints > 0,
infectedpoints%%1 == 0,
infectedpoints >= 0,
days > 0,
border > 0,
steplength > 0,
transmissiondistance > 0,
p > 0 && p <= 1,
infectiondays > 0,
ptest > 0 && ptest <= 1,
timetoquarantine >= 0,
quarantinelength > 1,
quarantinesteps > 0,
sidelengthquarantinesquare != 0,
immunedays >= 0,
p_mvt_to_center <= 1,
p_mvt_to_center >= 0,
-border < marketplace_x,
marketplace_x < border,
-border < marketplace_y,
marketplace_y < border,
travelspeed >= 0,
travelspeed <= (border/3),
travelfrequency >= 0,
"Steplength must be at least 5 times smaller than border" = steplength*5 <= abs(border),
"Sidelength of the quarantine square cannot be larger than one fifth of the border length" =  5 * sidelengthquarantinesquare<= border,
"Steplength in quarantine must be at least 2 times smaller than Sidelength of the quarantine square" = quarantinesteps *2 <= sidelengthquarantinesquare)
### The probability for every person that he/she gets himself/herself tested when he/she is sick and that the test really is positive when it should be
ptested <- lapply(rep(ptest, (infectedpoints+healthypoints)), wahrscheinlichkeit)
### Create two list of tibbles with random movement
if(infectedpoints > 0){
listoftibs1 <- tiberzeugen(infectedpoints, days, steplength, border)
# Set all tibbles in first list to infected, all in second to not infected, and the other paramteres corresponding to this
for(i in 1:length(listoftibs1)){
listoftibs1[[i]] <- tibble(listoftibs1[[i]], infected = "not infected",immune = FALSE, quarantine = FALSE, gets_tested = 0, trip_to_market = FALSE)
listoftibs1[[i]]$infected[1:min(infectiondays,days)] <- "infected"
listoftibs1[[i]]$gets_tested <- ptested[[i]]
listoftibs1[[i]]$immune[1:min((infectiondays+immunedays), days)] <- TRUE
listoftibs1[[i]]$counted <- TRUE
}
}
if(healthypoints > 0){
listoftibs2 <- tiberzeugen(healthypoints, days, steplength, border)
for(i in 1:length(listoftibs2)){
listoftibs2[[i]] <- tibble(listoftibs2[[i]], infected = "not infected",immune = FALSE, quarantine = FALSE, gets_tested = 0, trip_to_market = FALSE)
listoftibs2[[i]]$gets_tested <- ptested[[infectedpoints+i]]
listoftibs2[[i]]$counted <- FALSE
}
}
### Attribute to count how many of the people got infected at least once
gesamtinfiziert <- infectedpoints
# Connect both lists: from now on it does not matter if they were infected in the beginning, what matters is the current value
if(healthypoints > 0 && infectedpoints > 0) listoftibs <- c(listoftibs1, listoftibs2)
if(healthypoints <= 0 && infectedpoints > 0) listoftibs <- listoftibs1
if(healthypoints > 0 && infectedpoints <= 0) listoftibs <- listoftibs2
if(mvt_to_center == T){
for(i in 1:length(listoftibs)){
wkeit <- wahrscheinlichkeit(p_mvt_to_center)
if(wkeit == TRUE){
listoftibs[[i]] <- bewegungzumzentrum(listoftibs[[i]], zentrum_x = marketplace_x, zentrum_y = marketplace_y, speed = travelspeed, frequenz_besuche = travelfrequency)
}
}
}
# Go through every step of the time
#days <- length(listoftibs1[[1]]$x)
for(i in 1:(days-1)){
for(m in 1:length(listoftibs)){
for(n in 1:length(listoftibs)){
#First get the infected ones in quarantine
if(listoftibs[[n]]$infected[i] == "infected" && all(listoftibs[[n]]$quarantine[i:min(i+timetoquarantine,days)] == FALSE) == TRUE && quarantine == TRUE && listoftibs[[n]]$gets_tested[1] == TRUE){
quarantineborder <- border+sidelengthquarantinesquare
end <- min(i+timetoquarantine+quarantinelength-1, days)
if(i+timetoquarantine+quarantinelength<days){
laenge <- quarantinelength
}else{
laenge <- days-(i+timetoquarantine)
}
if(laenge>1){
move <- bewegunginquarantine(laenge, steplength = quarantinesteps, border = quarantineborder, bigsquare = border)
listoftibs[[n]]$x[min((i+timetoquarantine), days):end] <- unlist(move[[1]])
listoftibs[[n]]$y[min((i+timetoquarantine), days):end] <- unlist(move[[2]])
listoftibs[[n]]$quarantine[min((i+timetoquarantine), days):end] <- TRUE
}
}
#Check if one could infect the other; through the for-loop with the parameter i we are in the same time for both tibbles
if(n != m && listoftibs[[n]]$quarantine[i] == FALSE && listoftibs[[m]]$quarantine[i] == FALSE){
if((listoftibs[[m]]$infected[i] == "infected" && listoftibs[[n]]$infected[i] == "not infected")| (listoftibs[[n]]$infected[i] == "infected"&& listoftibs[[m]]$infected[i] == "not infected")){
#Claculate the distance between the points
diffx <- listoftibs[[m]]$x[i]-listoftibs[[n]]$x[i]
diffy <- listoftibs[[m]]$y[i]-listoftibs[[n]]$y[i]
a <- sqrt(diffx^2+diffy^2)
if(a < transmissiondistance){
#Probability that the infected one will infect the healthy one
p <- wahrscheinlichkeit(p)
if(p == TRUE){
if(listoftibs[[m]]$infected[i] == "infected" && listoftibs[[n]]$infected[i] == "not infected" && listoftibs[[n]]$immune[i] == "FALSE"){
listoftibs[[n]]$infected[min((i+1),days):min((i+1+infectiondays),days)] <- "infected"
listoftibs[[n]]$immune[min((i+1), days):min((i+1+infectiondays+immunedays), days)] <- TRUE
if(listoftibs[[n]]$counted[i] == "FALSE"){
gesamtinfiziert <- gesamtinfiziert+1
listoftibs[[n]]$counted[i:days] <- TRUE
}
}
if(listoftibs[[n]]$infected[i] == "infected" && listoftibs[[m]]$infected[i] == "not infected" && listoftibs[[m]]$immune[i] == "FALSE"){
listoftibs[[m]]$infected[min((i+1),days):min((i+1+infectiondays), days)] <- "infected"
listoftibs[[m]]$immune[min((i+1),days):min((i+1+infectiondays+immunedays),days)] <- TRUE
if(listoftibs[[m]]$counted[i] == "FALSE"){
gesamtinfiziert <- gesamtinfiziert+1
listoftibs[[m]]$counted[i:days] <- TRUE
}
}
}
}
}
}
}
}
}
aktuellinfiziert <- rep(0, days)
aktuellinfiziert[1] <- infectedpoints
for(i in 2:days){
aktuellinfiziert[i] <- aktuellinfiziert[i-1]
for(m in 1:length(listoftibs)){
if(listoftibs[[m]]$infected[i-1] == "infected" && listoftibs[[m]]$infected[i] == "not infected")
{
aktuellinfiziert[i] <- aktuellinfiziert[i]-1
}
if(listoftibs[[m]]$infected[i-1] == "not infected" && listoftibs[[m]]$infected[i] == "infected"){
aktuellinfiziert[i] <- aktuellinfiziert[i]+1
}
}
}
aktinf <- tibble("time" = 1:days, "current_infected" = aktuellinfiziert)
listoftibs <- c(listoftibs, "gesamtinfiziert" = gesamtinfiziert, "border" = border)
listoftibs[[length(listoftibs)+1]] <- aktinf
return(listoftibs)
}
erg <- individualSimulation(quarantine = TRUE, timetoquarantine = 10, quarantinelength = 1)
erg <- individualSimulation(quarantine = TRUE, timetoquarantine = 1, quarantinelength = 7)
print(erg[[1]], n = 13)
devtools::document()
#' @param methodlist the methods used to create the adjacency matrix.
#' @param thresh the threshold under which the values of the correlations are relevant.
#' @details
#' First the method creates the adjacency matrix out of the matrix A and after that the adjacency matrix can be
#' used to create the Igraph and its clusters.
#' @return The method returns a list with the Igraph from A and its clusters.
#' @example
#' create.Igraphclustering(x1, list("Spearman"))
#' @export
#'
create.Igraphclustering <- function(A, methodlist, thresh = 0.05){
cm.x1 <- create.adjacency.matrix(A, methodlist, thresh)
# Make an Igraph object from this matrix:
g.x1<-graph.adjacency(cm.x1,weighted=TRUE, mode="undirected", diag=FALSE)
# Simplfy the adjacency object
g.x1<-simplify(g.x1, remove.multiple=TRUE, remove.loops=TRUE)
# Colour negative correlation edges as red
#E(g.x1)[which(E(g.x1)$weight<0)]$color <- "red"
# Colour positive correlation edges as blue
#E(g.x1)[which(E(g.x1)$weight>0)]$color <- "blue"
# Convert edge weights to absolute values
#E(g.x1)$weight <- abs(E(g.x1)$weight)
# let's see if we have communities here using the
# Grivan-Newman algorithm
# 1st we calculate the edge betweenness, merges, etc...
g.communities.x1 <- edge.betweenness.community(g.x1, weights=NULL, directed=FALSE)
g.clustering.x1 <- make_clusters(g.x1, membership=g.communities.x1$membership)
V(g.x1)$color <- g.communities.x1$membership
list(g.clustering.x1, g.x1)
}
devtools::document()
devtools::load_all()
setwd("C:/Eigene Dateien/Hiwi/DNTPaket")
devtools::load_all()
devtools::document()
devtools::document()
devtools::load_all()
devtools::document()
devtools::load_all()
devtools::load_all()
#' @param tSize the size of the names inside the vertices.
#' @param filename the directory where the file shall be saved.
#' @details
#' The graphs are plotted with the same layout and other plot characteristics so that the two graphs are easy to
#' compare. The left network is the Survivors Admission and the right one the Survivor Event.
#' @return
#' @examples
#' graph.plot(x1,x2, list("Spearman), caption = "Spearman")
#' @export
#'
graph.plot <- function(A, B, methodlist, cluster = TRUE, negcol = "red", poscol= "blue", caption, layout = layout.fruchterman.reingold, vSize = 16, tSize = 0.8, directory){
stopifnot("cluster needs be boolean" = cluster==TRUE || cluster==FALSE,
"negcol and poscol need to be strings" = class(negcol)=="character" && class(poscol)=="character",
"caption needs to be a string" = class(caption)=="character",
"layout needs to be a layout-function" = class(layout)=="function",
"vSize and tSize need to be positive numbers" = (class(vSize)=="numeric" || class(vSize)=="integer") &&
(class(tSize)=="numeric" || class(tSize)=="integer"),
"vSize needs to be 20 times bigger than tSize to have a good relation between the names and the vertices" = tSize*20<=vSize,
"directory needs to be a string" = class(directory)=="character")
g1 <- create.Igraphclustering(A, methodlist)
g2 <- create.Igraphclustering(B, methodlist)
E(g1[[2]])[which(E(g1[[2]])$weight<0)]$color <- negcol
E(g1[[2]])[which(E(g1[[2]])$weight>0)]$color <- poscol
E(g2[[2]])[which(E(g2[[2]])$weight<0)]$color <- negcol
E(g2[[2]])[which(E(g2[[2]])$weight>0)]$color <- poscol
E(g1[[2]])$weight <- abs(E(g1[[2]])$weight)
E(g2[[2]])$weight <- abs(E(g2[[2]])$weight)
filename <- stringr::str_glue(directory, ".pdf", sep ="")
pdf(file=filename,width=15,height=8)#,pointsize=15)
par(mfrow=c(1,2),oma=c(0,0,2,0))
if(cluster == TRUE){
plot(
g1[[1]], g1[[2]],
layout= layout,
edge.curved=TRUE,
vertex.size=vSize,
#vertex.label.dist=-0.5,
#vertex.label.color="red",
#asp=1,
vertex.label.cex=tSize,
edge.width=E(g1[[2]])$weight*4,
edge.color = E(g1[[2]])$color,
edge.arrow.mode=FALSE,
main="Survivors Admission")
plot(
g2[[1]], g2[[2]],
layout=layout,
edge.curved=TRUE,
vertex.size=vSize,
#vertex.label.dist=-0.5,
#vertex.label.color="black",
#asp=FALSE,
vertex.label.cex=tSize,
edge.width=E(g2[[2]])$weight*4,
edge.color = E(g2[[2]])$color,
edge.arrow.mode=FALSE,
main="Survivors Event")
}else{
plot(
g1[[2]],
layout=layout,
edge.curved=TRUE,
vertex.size=vSize,
#vertex.label.dist=-0.5,
#vertex.label.color=E(g1[[2]])$color,
#asp=FALSE,
vertex.label.cex=tSize,
edge.width=E(g1[[2]])$weight*4,
edge.arrow.mode=FALSE,
main="Survivors Admission")
plot(
g2[[2]],
layout=layout,
edge.curved=TRUE,
vertex.size=vSize,
#vertex.label.dist=-0.5,
#vertex.label.color="black",
#asp=FALSE,
vertex.label.cex=tSize,
edge.width=E(g2[[2]])$weight*4,
edge.arrow.mode=FALSE,
main="Survivors Event")
}
#caption <- methodlist[[1]]
mtext(caption,outer=TRUE,cex=1.5)
dev.off()
}
#' @param methodlist the methods used to create the adjacency matrix.
#' @param thresh the threshold under which the values of the correlations are relevant.
#' @details
#' First the method creates the adjacency matrix out of the matrix A and after that the adjacency matrix can be
#' used to create the Igraph and its clusters.
#' @return The method returns a list with the Igraph from A and its clusters.
#' @example
#' create.Igraphclustering(x1, list("Spearman"))
#' @export
#'
create.Igraphclustering <- function(A, methodlist, thresh = 0.05){
cm.x1 <- create.adjacency.matrix(A, methodlist, thresh)
# Make an Igraph object from this matrix:
g.x1<-graph.adjacency(cm.x1,weighted=TRUE, mode="undirected", diag=FALSE)
# Simplfy the adjacency object
g.x1<-simplify(g.x1, remove.multiple=TRUE, remove.loops=TRUE)
# Colour negative correlation edges as red
#E(g.x1)[which(E(g.x1)$weight<0)]$color <- "red"
# Colour positive correlation edges as blue
#E(g.x1)[which(E(g.x1)$weight>0)]$color <- "blue"
# Convert edge weights to absolute values
#E(g.x1)$weight <- abs(E(g.x1)$weight)
# let's see if we have communities here using the
# Grivan-Newman algorithm
# 1st we calculate the edge betweenness, merges, etc...
g.communities.x1 <- edge.betweenness.community(g.x1, weights=NULL, directed=FALSE)
g.clustering.x1 <- make_clusters(g.x1, membership=g.communities.x1$membership)
V(g.x1)$color <- g.communities.x1$membership
list(g.clustering.x1, g.x1)
}
devtools::load_all()
rm()
rm(list = c("create.Igraphclustering", "graph.plot"))
devtools::load_all()
devtools::load_all()
devtools::document()
devtools::load_all()
create.adjacency.matrix(diag(1, nrow = 3, ncol = 3))
create.adjacency.matrix(diag(1, nrow = 5, ncol = 5))
create.adjacency.matrix(diag(1, nrow = 5, ncol = 5), list("Spearman"))
