clusnum.mst<-length(unique(mst.communities$membership))
##number of isolated nodes (i.e. nodes with degree 0)
numisolnodes.mst<-length(which(deg.mst==0))
output<-list(cm,g,g.communities,g.clustering,deg.g,edgenum.g,clusnum.g,numisolnodes.g,mst,mst.communities,mst.clustering,deg.mst,edgenum.mst,clusnum.mst,numisolnodes.mst)
names(output)<-c("adjacency matrix","graph","graph communities","graph clustering","graph vertex degrees","graph number of edges","graph number of clusters","Graph number of isolated nodes","MST","MST communities","MST clustering","MST vertex degrees","MST number of edges","MST number of clusters","MST number of isolated nodes")
return(output)
}
}
###compute score for original unpermuted raw data
graph.A<-create.graph(A,method=method,thresh=thresh,adj.method=adj.method,corm.ebicglasso=corm.ebicglasso,tun.ebicglasso=tun.ebicglasso)
graph.B<-create.graph(B,method=method,thresh=thresh,adj.method=adj.method,corm.ebicglasso=corm.ebicglasso,tun.ebicglasso=tun.ebicglasso)
value.orig<-diff.num(graph.A,graph.B)
names(value.orig)<-c("Graph Diff num of edges","Graph Diff num of clusters","Graph Diff num of isolated nodes","MST Diff num of edges","MST Diff num of clusters","MST Diff num of isolated nodes")
if(paired==FALSE){
D<-rbind(A,B)
#####function to create permutations from raw data
create.permut.unpaired<-function(seedex){
set.seed(seedex)
s<-sample(nrow(D),replace=FALSE)
D.new<-D[s,]
A.new<-D.new[1:nrow(A),]
B.new<-D.new[(nrow(A)+1):(nrow(D.new)),]
output<-list(A.new,B.new)
return(output)
}
##create permutations for raw data
shuffle <- lapply(1:permnum, create.permut.unpaired)
}
if(paired==TRUE){
#####function to create permutations from raw data
create.permut.paired<-function(seedex){
set.seed(seedex)
s<-sample(c("A","B"),nrow(A),replace=TRUE)
A.new<-rbind(A[s=="A",],B[s=="B",])
B.new<-rbind(B[s=="A",],A[s=="B",])
output<-list(A.new,B.new)
return(output)
}
##create permutations for raw data
shuffle <- lapply(1:permnum, create.permut.paired)
}
##compute score for the permnum permuted data sets
value.perm<-array(data=NA,dim=c(permnum,length(value.orig)))
for (n in 1:permnum){
graph.A.perm<-create.graph(shuffle[[n]][[1]],method=method,thresh=thresh,adj.method=adj.method,corm.ebicglasso=corm.ebicglasso,tun.ebicglasso=tun.ebicglasso)
graph.B.perm<-create.graph(shuffle[[n]][[2]],method=method,thresh=thresh,adj.method=adj.method,corm.ebicglasso=corm.ebicglasso,tun.ebicglasso=tun.ebicglasso)
value.perm[n,]<-diff.num(graph.A.perm,graph.B.perm)
}
###permutation pseudocount p-value
pvalue.ecdf<-rep(NA,length(value.orig))
pvalue.ecdf.pseudo<-rep(NA,length(value.orig))
for (j in 1:length(value.orig)){
if(all(is.na(value.orig[j])==TRUE)){
pvalue.ecdf[j]<-NA
pvalue.ecdf.pseudo[j]<-NA
}
else{
if (all(is.na(value.perm[,j])==FALSE)){
num.extr<-sum(value.perm[,j]>=value.orig[j])
pvalue.ecdf[j]<-num.extr/permnum
pvalue.ecdf.pseudo[j]<-(1+num.extr)/(permnum+1)
}else{
permnum<-length(na.omit(value.perm[,j]))
num.extr<-sum(na.omit(value.perm[,j])>=value.orig[j])
pvalue.ecdf[j]<-num.extr/permnum
pvalue.ecdf.pseudo[j]<-(1+num.extr)/(permnum+1)
}
}
}
names(pvalue.ecdf)<-c("Graph Diff num of edges","Graph Diff num of clusters","Graph Diff num of isolated nodes","MST Diff num of edges","MST Diff num of clusters","MST Diff num of isolated nodes")
names(pvalue.ecdf.pseudo)<-c("Graph Diff num of edges","Graph Diff num of clusters","Graph Diff num of isolated nodes","MST Diff num of edges","MST Diff num of clusters","MST Diff num of isolated nodes")
output<-list(graph.A,graph.B,value.orig,value.perm,pvalue.ecdf,pvalue.ecdf.pseudo)
names(output)<-c("graph.A","graph.B","test.statistic","test.statistics.perm","pvalue","pvalue.pseudocount")
return(output)
}
degree.inv<-function(X,Y){
if(all(X==0)){
A<-graph.adjacency(X,weighted=TRUE, mode="undirected", diag=FALSE)
}else{
A<-graph.adjacency(X,weighted=TRUE, mode="undirected", diag=FALSE)
# Simplfy the adjacency object
A<-simplify(A, remove.multiple=TRUE, remove.loops=TRUE)
# Convert edge weights to absolute values
E(A)$weight <- abs(E(A)$weight)
}
if(all(Y==0)){
B<-graph.adjacency(Y,weighted=TRUE, mode="undirected", diag=FALSE)
}else{
B<-graph.adjacency(Y,weighted=TRUE, mode="undirected", diag=FALSE)
# Simplfy the adjacency object
B<-simplify(B, remove.multiple=TRUE, remove.loops=TRUE)
# Convert edge weights to absolute values
E(B)$weight <- abs(E(B)$weight)
}
degA<-degree(A)
degB<-degree(B)
output<-abs(degA-degB)
names(output)<-colnames(X)
return(output)
}
betweenness.inv<-function(X,Y){
if(all(X==0)){
A<-graph.adjacency(X,weighted=TRUE, mode="undirected", diag=FALSE)
}else{
A<-graph.adjacency(X,weighted=TRUE, mode="undirected", diag=FALSE)
# Simplfy the adjacency object
A<-simplify(A, remove.multiple=TRUE, remove.loops=TRUE)
# Convert edge weights to absolute values
E(A)$weight <- abs(E(A)$weight)
}
if(all(Y==0)){
B<-graph.adjacency(Y,weighted=TRUE, mode="undirected", diag=FALSE)
}else{
B<-graph.adjacency(Y,weighted=TRUE, mode="undirected", diag=FALSE)
# Simplfy the adjacency object
B<-simplify(B, remove.multiple=TRUE, remove.loops=TRUE)
# Convert edge weights to absolute values
E(B)$weight <- abs(E(B)$weight)
}
betA<-betweenness(A)
betB<-betweenness(B)
output<-abs(betA-betB)
names(output)<-colnames(X)
return(output)
}
closeness.inv<-function(X,Y){
if(all(X==0)){
A<-graph.adjacency(X,weighted=TRUE, mode="undirected", diag=FALSE)
}else{
A<-graph.adjacency(X,weighted=TRUE, mode="undirected", diag=FALSE)
# Simplfy the adjacency object
A<-simplify(A, remove.multiple=TRUE, remove.loops=TRUE)
# Convert edge weights to absolute values
E(A)$weight <- abs(E(A)$weight)
}
if(all(Y==0)){
B<-graph.adjacency(Y,weighted=TRUE, mode="undirected", diag=FALSE)
}else{
B<-graph.adjacency(Y,weighted=TRUE, mode="undirected", diag=FALSE)
# Simplfy the adjacency object
B<-simplify(B, remove.multiple=TRUE, remove.loops=TRUE)
# Convert edge weights to absolute values
E(B)$weight <- abs(E(B)$weight)
}
cloA<-closeness(A)
cloB<-closeness(B)
output<-abs(cloA-cloB)
names(output)<-colnames(X)
return(output)
}
eigcen.inv<-function(X,Y){
if(all(X==0)){
A<-graph.adjacency(X,weighted=TRUE, mode="undirected", diag=FALSE)
}else{
A<-graph.adjacency(X,weighted=TRUE, mode="undirected", diag=FALSE)
# Simplfy the adjacency object
A<-simplify(A, remove.multiple=TRUE, remove.loops=TRUE)
# Convert edge weights to absolute values
E(A)$weight <- abs(E(A)$weight)
}
if(all(Y==0)){
B<-graph.adjacency(Y,weighted=TRUE, mode="undirected", diag=FALSE)
}else{
B<-graph.adjacency(Y,weighted=TRUE, mode="undirected", diag=FALSE)
# Simplfy the adjacency object
B<-simplify(B, remove.multiple=TRUE, remove.loops=TRUE)
# Convert edge weights to absolute values
E(B)$weight <- abs(E(B)$weight)
}
ecA<-eigen_centrality(A)$vector
ecB<-eigen_centrality(B)$vector
output<-abs(ecA-ecB)
names(output)<-colnames(X)
return(output)
}
perm.test.nw.nodes<-function(A,B,permnum,method,thresh,adj.method,corm.ebicglasso,tun.ebicglasso,score.funct,paired=FALSE){
##function to create adjacency matrix corresponding to raw data
create.adjacency.matrix<-function(A,method,thresh=0.05,adj.method,corm.ebicglasso,tun.ebicglasso){
if(method=="Spearman"){
correls<-rcorr(as.matrix(A),type="spearman")
cm<-correls$r
# Keep only correlations with p-value <=thresh
diag(cm)<-0
cm[correls$P>thresh]<-0
}
if(method=="PCSpearman"){
correls<-pcor(as.matrix(A),method="spearman")
cm<-correls$estimate
# Keep only correlations with p-value <=thresh
diag(cm)<-0
cm[correls$p.value>thresh]<-0
}
if(method=="Spearman.adj"){
correls<-rcorr(as.matrix(A),type="spearman")
cm<-correls$r
pmat<-correls$P
ltri<-lower.tri(pmat)
utri<-upper.tri(pmat)
pmat[ltri]<-p.adjust(pmat[ltri], method = adj.method)
pmat[utri]<-t(pmat)[utri]
# Keep only correlations with adjusted p-value <=thresh
diag(cm)<-0
cm[pmat>thresh]<-0
}
if(method=="PCSpearman.adj"){
correls<-pcor(as.matrix(A),method="spearman")
cm<-correls$estimate
pmat<-correls$p.value
ltri<-lower.tri(pmat)
utri<-upper.tri(pmat)
pmat[ltri]<-p.adjust(pmat[ltri], method = adj.method)
pmat[utri]<-t(pmat)[utri]
# Keep only correlations with adjusted p-value <=thresh
diag(cm)<-0
cm[pmat>0.05]<-0
}
if(method=="DistCorr"){
A<-as.matrix(A)
cm<-array(data=NA,dim=c(dim(A)[2],dim(A)[2]))
for(i in 1:dim(A)[2]){
for(j in 1:dim(A)[2]){
cm[i,j]<-dcor(A[,i],A[,j],index=1.0)
}}
rownames(cm)<-colnames(A)
colnames(cm)<-colnames(A)
##compute p-values based on 10000 permutations
pvals<-array(data=NA,dim=c(dim(A)[2],dim(A)[2]))
for(i in 1:dim(A)[2]){
for(j in 1:dim(A)[2]){
set.seed(24)
pvals[i,j]<-dcor.test(A[,i],A[,j],index=1.0,R=10000)$p.value
}}
rownames(pvals)<-colnames(A)
colnames(pvals)<-colnames(A)
# Keep only correlations with p-value <=thresh
diag(cm)<-0
cm[pvals>thresh]<-0
}
if(method=="DistCorr.adj"){
A<-as.matrix(A)
cm<-array(data=NA,dim=c(dim(A)[2],dim(A)[2]))
for(i in 1:dim(A)[2]){
for(j in 1:dim(A)[2]){
cm[i,j]<-dcor(A[,i],A[,j],index=1.0)
}}
rownames(cm)<-colnames(A)
colnames(cm)<-colnames(A)
##compute p-values based on 10000 permutations
pvals<-array(data=NA,dim=c(dim(A)[2],dim(A)[2]))
for(i in 1:dim(A)[2]){
for(j in 1:dim(A)[2]){
set.seed(24)
pvals[i,j]<-dcor.test(A[,i],A[,j],index=1.0,R=10000)$p.value
}}
rownames(pvals)<-colnames(A)
colnames(pvals)<-colnames(A)
pmat<-pvals
ltri<-lower.tri(pmat)
utri<-upper.tri(pmat)
pmat[ltri]<-p.adjust(pmat[ltri], method = adj.method)
pmat[utri]<-t(pmat)[utri]
rownames(pmat)<-colnames(A)
colnames(pmat)<-colnames(A)
# Keep only correlations with adjusted p-value <=thresh
diag(cm)<-0
cm[pmat>thresh]<-0
}
if(method=="EBICglasso"){
correls<-cor(A,method=corm.ebicglasso)
cm<-EBICglasso(correls,n=dim(A)[1],gamma=tun.ebicglasso)
# Keep only correlations with p-value <=thresh; NOT NECESSARY FOR EBICGLASSO, AS VARIABLE SELECTION IS PERFORMED
diag(cm)<-0
#cm[correls$p.value>thresh]<-0
}
output<-cm
return(output)
}
###compute score for original unpermuted raw data
adj.A<-create.adjacency.matrix(A,method=method,thresh=thresh,adj.method=adj.method,corm.ebicglasso=corm.ebicglasso,tun.ebicglasso=tun.ebicglasso)
adj.B<-create.adjacency.matrix(B,method=method,thresh=thresh,adj.method=adj.method,corm.ebicglasso=corm.ebicglasso,tun.ebicglasso=tun.ebicglasso)
value.orig<-score.funct(adj.A,adj.B)
if(paired==FALSE){
D<-rbind(A,B)
#####function to create permutations from raw data
create.permut.unpaired<-function(seedex){
set.seed(seedex)
s<-sample(nrow(D),replace=FALSE)
D.new<-D[s,]
A.new<-D.new[1:nrow(A),]
B.new<-D.new[(nrow(A)+1):(nrow(D.new)),]
output<-list(A.new,B.new)
return(output)
}
##create permutations for raw data
shuffle <- lapply(1:permnum, create.permut.unpaired)
}
if(paired==TRUE){
#####function to create permutations from raw data
create.permut.paired<-function(seedex){
set.seed(seedex)
s<-sample(c("A","B"),nrow(A),replace=TRUE)
A.new<-rbind(A[s=="A",],B[s=="B",])
B.new<-rbind(B[s=="A",],A[s=="B",])
output<-list(A.new,B.new)
return(output)
}
##create permutations for raw data
shuffle <- lapply(1:permnum, create.permut.paired)
}
##compute score for the permnum permuted data sets
value.perm<-array(data=NA,dim=c(permnum,length(value.orig)))
for (n in 1:permnum){
adj.A.perm<-create.adjacency.matrix(shuffle[[n]][[1]],method=method,thresh=thresh,adj.method=adj.method,corm.ebicglasso=corm.ebicglasso,tun.ebicglasso=tun.ebicglasso)
adj.B.perm<-create.adjacency.matrix(shuffle[[n]][[2]],method=method,thresh=thresh,adj.method=adj.method,corm.ebicglasso=corm.ebicglasso,tun.ebicglasso=tun.ebicglasso)
value.perm[n,]<-score.funct(adj.A.perm,adj.B.perm)
}
###permutation pseudocount p-value
pvalue.ecdf<-rep(NA,length(value.orig))
pvalue.ecdf.pseudo<-rep(NA,length(value.orig))
names(pvalue.ecdf)<-names(value.orig)
names(pvalue.ecdf.pseudo)<-names(value.orig)
for(i in 1:length(value.orig)){
num.extr<-sum(value.perm[,i]>=value.orig[i])
pvalue.ecdf[i]<-num.extr/permnum
pvalue.ecdf.pseudo[i]<-(1+num.extr)/(permnum+1)
}
output<-list(adj.A,adj.B,value.orig,value.perm,pvalue.ecdf,pvalue.ecdf.pseudo) #,p.ecdf,p.ecdf.pseudo)
names(output)<-c("adjancency.matrix.A","adjacency.matrix.B","test.statistic","test.statistics.perm","pvalue","pvalue.pseudocount")
return(output)
}
##a. "considers directions (signs) of correlations"
edge.inv.direc<-function(A,B){
output<-abs(A-B)
rownames(output)<-rownames(A)
colnames(output)<-colnames(A)
return(output)
}
##b. "does not consider directions (signs) of correlations"
edge.inv<-function(A,B){
output<-abs(abs(A)-abs(B))
rownames(output)<-rownames(A)
colnames(output)<-colnames(A)
return(output)
}
perm.test.nw.edges<-function(A,B,permnum,method,thresh,adj.method,corm.ebicglasso,tun.ebicglasso,score.funct,paired=FALSE){
##function to create adjacency matrix corresponding to raw data
create.adjacency.matrix<-function(A,method,thresh=0.05,adj.method,corm.ebicglasso,tun.ebicglasso){
if(method=="Spearman"){
correls<-rcorr(as.matrix(A),type="spearman")
cm<-correls$r
# Keep only correlations with p-value <=thresh
diag(cm)<-0
cm[correls$P>thresh]<-0
}
if(method=="PCSpearman"){
correls<-pcor(as.matrix(A),method="spearman")
cm<-correls$estimate
# Keep only correlations with p-value <=thresh
diag(cm)<-0
cm[correls$p.value>thresh]<-0
}
if(method=="Spearman.adj"){
correls<-rcorr(as.matrix(A),type="spearman")
cm<-correls$r
pmat<-correls$P
ltri<-lower.tri(pmat)
utri<-upper.tri(pmat)
pmat[ltri]<-p.adjust(pmat[ltri], method = adj.method)
pmat[utri]<-t(pmat)[utri]
# Keep only correlations with adjusted p-value <=thresh
diag(cm)<-0
cm[pmat>thresh]<-0
}
if(method=="PCSpearman.adj"){
correls<-pcor(as.matrix(A),method="spearman")
cm<-correls$estimate
pmat<-correls$p.value
ltri<-lower.tri(pmat)
utri<-upper.tri(pmat)
pmat[ltri]<-p.adjust(pmat[ltri], method = adj.method)
pmat[utri]<-t(pmat)[utri]
# Keep only correlations with adjusted p-value <=thresh
diag(cm)<-0
cm[pmat>0.05]<-0
}
if(method=="DistCorr"){
A<-as.matrix(A)
cm<-array(data=NA,dim=c(dim(A)[2],dim(A)[2]))
for(i in 1:dim(A)[2]){
for(j in 1:dim(A)[2]){
cm[i,j]<-dcor(A[,i],A[,j],index=1.0)
}}
rownames(cm)<-colnames(A)
colnames(cm)<-colnames(A)
##compute p-values based on 10000 permutations
pvals<-array(data=NA,dim=c(dim(A)[2],dim(A)[2]))
for(i in 1:dim(A)[2]){
for(j in 1:dim(A)[2]){
set.seed(24)
pvals[i,j]<-dcor.test(A[,i],A[,j],index=1.0,R=10000)$p.value
}}
rownames(pvals)<-colnames(A)
colnames(pvals)<-colnames(A)
# Keep only correlations with p-value <=thresh
diag(cm)<-0
cm[pvals>thresh]<-0
}
if(method=="DistCorr.adj"){
A<-as.matrix(A)
cm<-array(data=NA,dim=c(dim(A)[2],dim(A)[2]))
for(i in 1:dim(A)[2]){
for(j in 1:dim(A)[2]){
cm[i,j]<-dcor(A[,i],A[,j],index=1.0)
}}
rownames(cm)<-colnames(A)
colnames(cm)<-colnames(A)
##compute p-values based on 10000 permutations
pvals<-array(data=NA,dim=c(dim(A)[2],dim(A)[2]))
for(i in 1:dim(A)[2]){
for(j in 1:dim(A)[2]){
set.seed(24)
pvals[i,j]<-dcor.test(A[,i],A[,j],index=1.0,R=10000)$p.value
}}
rownames(pvals)<-colnames(A)
colnames(pvals)<-colnames(A)
pmat<-pvals
ltri<-lower.tri(pmat)
utri<-upper.tri(pmat)
pmat[ltri]<-p.adjust(pmat[ltri], method = adj.method)
pmat[utri]<-t(pmat)[utri]
rownames(pmat)<-colnames(A)
colnames(pmat)<-colnames(A)
# Keep only correlations with adjusted p-value <=thresh
diag(cm)<-0
cm[pmat>thresh]<-0
}
if(method=="EBICglasso"){
correls<-cor(A,method=corm.ebicglasso)
cm<-EBICglasso(correls,n=dim(A)[1],gamma=tun.ebicglasso)
# Keep only correlations with p-value <=thresh; NOT NECESSARY FOR EBICGLASSO, AS VARIABLE SELECTION IS PERFORMED
diag(cm)<-0
#cm[correls$p.value>thresh]<-0
}
output<-cm
return(output)
}
###compute score for original unpermuted raw data
adj.A<-create.adjacency.matrix(A,method=method,thresh=thresh,adj.method=adj.method,corm.ebicglasso=corm.ebicglasso,tun.ebicglasso=tun.ebicglasso)
adj.B<-create.adjacency.matrix(B,method=method,thresh=thresh,adj.method=adj.method,corm.ebicglasso=corm.ebicglasso,tun.ebicglasso=tun.ebicglasso)
value.orig<-score.funct(adj.A,adj.B)
if(paired==FALSE){
D<-rbind(A,B)
#####function to create permutations from raw data
create.permut.unpaired<-function(seedex){
set.seed(seedex)
s<-sample(nrow(D),replace=FALSE)
D.new<-D[s,]
A.new<-D.new[1:nrow(A),]
B.new<-D.new[(nrow(A)+1):(nrow(D.new)),]
output<-list(A.new,B.new)
return(output)
}
##create permutations for raw data
shuffle <- lapply(1:permnum, create.permut.unpaired)
}
if(paired==TRUE){
#####function to create permutations from raw data
create.permut.paired<-function(seedex){
set.seed(seedex)
s<-sample(c("A","B"),nrow(A),replace=TRUE)
A.new<-rbind(A[s=="A",],B[s=="B",])
B.new<-rbind(B[s=="A",],A[s=="B",])
output<-list(A.new,B.new)
return(output)
}
##create permutations for raw data
shuffle <- lapply(1:permnum, create.permut.paired)
}
##compute score for the permnum permuted data sets
value.perm<-array(data=NA,dim=c(permnum,dim(adj.A)))
for (n in 1:permnum){
adj.A.perm<-create.adjacency.matrix(shuffle[[n]][[1]],method=method,thresh=thresh,adj.method=adj.method,corm.ebicglasso=corm.ebicglasso,tun.ebicglasso=tun.ebicglasso)
adj.B.perm<-create.adjacency.matrix(shuffle[[n]][[2]],method=method,thresh=thresh,adj.method=adj.method,corm.ebicglasso=corm.ebicglasso,tun.ebicglasso=tun.ebicglasso)
value.perm[n,,]<-score.funct(adj.A.perm,adj.B.perm)
}
###permutation pseudocount p-value
pvalue.ecdf<-array(data=NA,dim=dim(value.orig),dimnames=list(rownames(value.orig),colnames(value.orig)))
pvalue.ecdf.pseudo<-array(data=NA,dim=dim(value.orig),dimnames=list(rownames(value.orig),colnames(value.orig)))
for(i in 1:dim(value.orig)[1]){
for(j in 1:dim(value.orig)[2]){
num.extr<-sum(value.perm[,i,j]>=value.orig[i,j])
pvalue.ecdf[i,j]<-num.extr/permnum
pvalue.ecdf.pseudo[i,j]<-(1+num.extr)/(permnum+1)
}
}
p.ecdf<-data.frame(var1=rownames(pvalue.ecdf)[row(pvalue.ecdf)[upper.tri(pvalue.ecdf)]],
var2=colnames(pvalue.ecdf)[col(pvalue.ecdf)[upper.tri(pvalue.ecdf)]],
pvalue=pvalue.ecdf[upper.tri(pvalue.ecdf)])
p.ecdf.pseudo<-data.frame(var1=rownames(pvalue.ecdf.pseudo)[row(pvalue.ecdf.pseudo)[upper.tri(pvalue.ecdf.pseudo)]],
var2=colnames(pvalue.ecdf.pseudo)[col(pvalue.ecdf.pseudo)[upper.tri(pvalue.ecdf.pseudo)]],
pvalue=pvalue.ecdf.pseudo[upper.tri(pvalue.ecdf.pseudo)])
output<-list(adj.A,adj.B,value.orig,value.perm,pvalue.ecdf,pvalue.ecdf.pseudo,p.ecdf,p.ecdf.pseudo)
names(output)<-c("adjancency.matrix.A","adjacency.matrix.B","test.statistic","test.statistics.perm","pvalue","pvalue.pseudocount","pvalue.summ","pvalue.pseudocount.summ")
return(output)
}
perm.test.nw(x1, x2, 10, "EBICglasso", 0.05, "pearson", 0.02, global.str, FALSE)
perm.test.nw(A = x1, B = x2, permnum = 10, method = "EBICglasso", thresh = 0.05, corm.ebicglasso = "pearson",tun.ebicglasso =  0.02, score.funt = global.str,paired =  FALSE)
perm.test.nw(A = x1, B = x2, permnum = 10, method = "EBICglasso", thresh = 0.05, corm.ebicglasso = "pearson",tun.ebicglasso =  0.02, score.funt = global.str,paired =  FALSE)
perm.test.nw(A = x1, B = x2, permnum = 10, method = "Spearman", thresh = 0.05, corm.ebicglasso = "pearson",tun.ebicglasso =  0.02, score.funt = global.str,paired =  FALSE)
perm.test.nw(A = x1, B = x2, permnum = 10, method = "Spearman", thresh = 0.05, corm.ebicglasso = "pearson",tun.ebicglasso =  0.02, score.funt = max.metr,paired =  FALSE)
perm.test.nw(A = x1, B = x2, permnum = 10, method = "Spearman", thresh = 0.05, corm.ebicglasso = "pearson",tun.ebicglasso =  0.02, score.funt = frobenius.metric,paired =  FALSE)
perm.test.nw(A = x1, B = x2, permnum = 10, method = "Spearman", thresh = 0.05, corm.ebicglasso = "pearson",tun.ebicglasso =  0.02, score.funt = frobenius.metric(),paired =  FALSE)
