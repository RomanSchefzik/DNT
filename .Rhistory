perm.test.nw(A = x1, B = x2, permnum = 10, methodlist = list("PCSpearman"), thresh = 0.05, score.funct = frobenius.metric)
devtools::document()
perm.test.nw(A = x1, B = x2, permnum = 10, methodlist = list("PCSpearman"), thresh = 0.05, score.funct = frobenius.metric)
devtools::document()
perm.test.nw(A = x1, B = x2, permnum = 10, methodlist = list("PCSpearman"), thresh = 0.05, score.funct = frobenius.metric)
#' @param thresh
#' @param score.funct the function used to compare the adjacency matrices A and B.
#' @param paried
#' @details
#' Details
#' @return Return
#' @examples
#' perm.test.nw(A = x1, B = x2, permnum = 10, methodlist = list("DistCorr"), thresh = 0.05, score.funct = frobenius.metric)
#' @export
#'
perm.test.nw<-function(A, B, permnum, methodlist, thresh, score.funct, paired=FALSE){
##function to create adjacency matrix corresponding to raw data
create.adjacency.matrix<-function(A,methodlist,thresh=0.05){
method <- methodlist[[1]]
if(method=="Spearman"){
correls<-rcorr(as.matrix(A),type="spearman")
cm<-correls$r
# Keep only correlations with p-value <=thresh
diag(cm)<-0
cm[correls$P>thresh]<-0
}
if(method=="PCSpearman"){
correls<-ppcor::pcor(as.matrix(A),method="spearman")
cm<-correls$estimate
# Keep only correlations with p-value <=thresh
diag(cm)<-0
cm[correls$p.value>thresh]<-0
}
if(method=="Spearman.adj"){
correls<-rcorr(as.matrix(A),type="spearman")
cm<-correls$r
pmat<-correls$P
ltri<-lower.tri(pmat)
utri<-upper.tri(pmat)
adj.method <- methodlist[[2]]
pmat[ltri]<-p.adjust(pmat[ltri], method = adj.method)
pmat[utri]<-t(pmat)[utri]
# Keep only correlations with adjusted p-value <=thresh
diag(cm)<-0
cm[pmat>thresh]<-0
}
if(method=="PCSpearman.adj"){
correls<-pcor(as.matrix(A),method="spearman")
cm<-correls$estimate
pmat<-correls$p.value
ltri<-lower.tri(pmat)
utri<-upper.tri(pmat)
adj.method <- methodlist[[2]]
pmat[ltri]<-p.adjust(pmat[ltri], method = adj.method)
pmat[utri]<-t(pmat)[utri]
# Keep only correlations with adjusted p-value <=thresh
diag(cm)<-0
cm[pmat>0.05]<-0
}
if(method=="DistCorr"){
A<-as.matrix(A)
cm<-array(data=NA,dim=c(dim(A)[2],dim(A)[2]))
for(i in 1:dim(A)[2]){
for(j in 1:dim(A)[2]){
cm[i,j]<-dcor(A[,i],A[,j],index=1.0)
}}
rownames(cm)<-colnames(A)
colnames(cm)<-colnames(A)
##compute p-values based on 10000 permutations
pvals<-array(data=NA,dim=c(dim(A)[2],dim(A)[2]))
for(i in 1:dim(A)[2]){
for(j in 1:dim(A)[2]){
set.seed(24)
pvals[i,j]<-dcor.test(A[,i],A[,j],index=1.0,R=10000)$p.value
}}
rownames(pvals)<-colnames(A)
colnames(pvals)<-colnames(A)
# Keep only correlations with p-value <=thresh
diag(cm)<-0
cm[pvals>thresh]<-0
}
if(method=="DistCorr.adj"){
A<-as.matrix(A)
cm<-array(data=NA,dim=c(dim(A)[2],dim(A)[2]))
for(i in 1:dim(A)[2]){
for(j in 1:dim(A)[2]){
cm[i,j]<-dcor(A[,i],A[,j],index=1.0)
}}
rownames(cm)<-colnames(A)
colnames(cm)<-colnames(A)
##compute p-values based on 10000 permutations
pvals<-array(data=NA,dim=c(dim(A)[2],dim(A)[2]))
for(i in 1:dim(A)[2]){
for(j in 1:dim(A)[2]){
set.seed(24)
pvals[i,j]<-dcor.test(A[,i],A[,j],index=1.0,R=10000)$p.value
}}
rownames(pvals)<-colnames(A)
colnames(pvals)<-colnames(A)
pmat<-pvals
ltri<-lower.tri(pmat)
utri<-upper.tri(pmat)
adj.method <- methodlist[[2]]
pmat[ltri]<-p.adjust(pmat[ltri], method = adj.method)
pmat[utri]<-t(pmat)[utri]
rownames(pmat)<-colnames(A)
colnames(pmat)<-colnames(A)
# Keep only correlations with adjusted p-value <=thresh
diag(cm)<-0
cm[pmat>thresh]<-0
}
if(method=="EBICglasso"){
corm.ebicglasso <- methodlist[[2]]
tun.ebicglasso <- methodlist[[3]]
correls<-cor(A,method=corm.ebicglasso)
cm<-EBICglasso(correls,n=dim(A)[1],gamma=tun.ebicglasso)
# Keep only correlations with p-value <=thresh; NOT NECESSARY FOR EBICGLASSO, AS VARIABLE SELECTION IS PERFORMED
diag(cm)<-0
#cm[correls$p.value>thresh]<-0
}
output<-cm
return(output)
}
###compute score for original unpermuted raw data
adj.A<-create.adjacency.matrix(A,methodlist=methodlist,thresh=thresh)
adj.B<-create.adjacency.matrix(B,methodlist=methodlist,thresh=thresh)
value.orig<-score.funct(adj.A,adj.B)
if(paired==FALSE){
D<-rbind(A,B)
#####function to create permutations from raw data
create.permut.unpaired<-function(seedex){
set.seed(seedex)
s<-sample(nrow(D),replace=FALSE)
D.new<-D[s,]
A.new<-D.new[1:nrow(A),]
B.new<-D.new[(nrow(A)+1):(nrow(D.new)),]
output<-list(A.new,B.new)
return(output)
}
##create permutations for raw data
shuffle <- lapply(1:permnum, create.permut.unpaired)
}
if(paired==TRUE){
#####function to create permutations from raw data
create.permut.paired<-function(seedex){
set.seed(seedex)
s<-sample(c("A","B"),nrow(A),replace=TRUE)
A.new<-rbind(A[s=="A",],B[s=="B",])
B.new<-rbind(B[s=="A",],A[s=="B",])
output<-list(A.new,B.new)
return(output)
}
##create permutations for raw data
shuffle <- lapply(1:permnum, create.permut.paired)
}
##compute score for the permnum permuted data sets
value.perm<-rep(NA,permnum)
for (n in 1:permnum){
adj.A.perm<-create.adjacency.matrix(shuffle[[n]][[1]],methodlist=methodlist,thresh=thresh)
adj.B.perm<-create.adjacency.matrix(shuffle[[n]][[2]],methodlist=methodlist,thresh=thresh)
value.perm[n]<-score.funct(adj.A.perm,adj.B.perm)
}
###permutation pseudocount p-value
num.extr<-sum(value.perm>=value.orig)
pvalue.ecdf<-num.extr/permnum
pvalue.ecdf.pseudo<-(1+num.extr)/(permnum+1)
output<-list(adj.A,adj.B,value.orig,value.perm,pvalue.ecdf,pvalue.ecdf.pseudo)
names(output)<-c("adjancency.matrix.A","adjacency.matrix.B","test.statistic","test.statistics.perm","pvalue","pvalue.pseudocount")
return(output)
}
perm.test.nw(A = x1, B = x2, permnum = 10, methodlist = list("PCSpearman"), thresh = 0.05, score.funct = frobenius.metric)
devtools::document()
perm.test.nw(A = x1, B = x2, permnum = 10, methodlist = list("PCSpearman"), thresh = 0.05, score.funct = frobenius.metric)
#' @param thresh
#' @param score.funct the function used to compare the adjacency matrices A and B.
#' @param paried
#' @details
#' Details
#' @return Return
#' @examples
#' perm.test.nw(A = x1, B = x2, permnum = 10, methodlist = list("DistCorr"), thresh = 0.05, score.funct = frobenius.metric)
#' @export
#'
perm.test.nw<-function(A, B, permnum, methodlist, thresh, score.funct, paired=FALSE){
##function to create adjacency matrix corresponding to raw data
create.adjacency.matrix<-function(A,methodlist,thresh=0.05){
method <- methodlist[[1]]
if(method=="Spearman"){
correls<-rcorr(as.matrix(A),type="spearman")
cm<-correls$r
# Keep only correlations with p-value <=thresh
diag(cm)<-0
cm[correls$P>thresh]<-0
}
if(method=="PCSpearman"){
correls<-pcor(as.matrix(A),method="spearman")
cm<-correls$estimate
# Keep only correlations with p-value <=thresh
diag(cm)<-0
cm[correls$p.value>thresh]<-0
}
if(method=="Spearman.adj"){
correls<-rcorr(as.matrix(A),type="spearman")
cm<-correls$r
pmat<-correls$P
ltri<-lower.tri(pmat)
utri<-upper.tri(pmat)
adj.method <- methodlist[[2]]
pmat[ltri]<-p.adjust(pmat[ltri], method = adj.method)
pmat[utri]<-t(pmat)[utri]
# Keep only correlations with adjusted p-value <=thresh
diag(cm)<-0
cm[pmat>thresh]<-0
}
if(method=="PCSpearman.adj"){
correls<-pcor(as.matrix(A),method="spearman")
cm<-correls$estimate
pmat<-correls$p.value
ltri<-lower.tri(pmat)
utri<-upper.tri(pmat)
adj.method <- methodlist[[2]]
pmat[ltri]<-p.adjust(pmat[ltri], method = adj.method)
pmat[utri]<-t(pmat)[utri]
# Keep only correlations with adjusted p-value <=thresh
diag(cm)<-0
cm[pmat>0.05]<-0
}
if(method=="DistCorr"){
A<-as.matrix(A)
cm<-array(data=NA,dim=c(dim(A)[2],dim(A)[2]))
for(i in 1:dim(A)[2]){
for(j in 1:dim(A)[2]){
cm[i,j]<-dcor(A[,i],A[,j],index=1.0)
}}
rownames(cm)<-colnames(A)
colnames(cm)<-colnames(A)
##compute p-values based on 10000 permutations
pvals<-array(data=NA,dim=c(dim(A)[2],dim(A)[2]))
for(i in 1:dim(A)[2]){
for(j in 1:dim(A)[2]){
set.seed(24)
pvals[i,j]<-dcor.test(A[,i],A[,j],index=1.0,R=10000)$p.value
}}
rownames(pvals)<-colnames(A)
colnames(pvals)<-colnames(A)
# Keep only correlations with p-value <=thresh
diag(cm)<-0
cm[pvals>thresh]<-0
}
if(method=="DistCorr.adj"){
A<-as.matrix(A)
cm<-array(data=NA,dim=c(dim(A)[2],dim(A)[2]))
for(i in 1:dim(A)[2]){
for(j in 1:dim(A)[2]){
cm[i,j]<-dcor(A[,i],A[,j],index=1.0)
}}
rownames(cm)<-colnames(A)
colnames(cm)<-colnames(A)
##compute p-values based on 10000 permutations
pvals<-array(data=NA,dim=c(dim(A)[2],dim(A)[2]))
for(i in 1:dim(A)[2]){
for(j in 1:dim(A)[2]){
set.seed(24)
pvals[i,j]<-dcor.test(A[,i],A[,j],index=1.0,R=10000)$p.value
}}
rownames(pvals)<-colnames(A)
colnames(pvals)<-colnames(A)
pmat<-pvals
ltri<-lower.tri(pmat)
utri<-upper.tri(pmat)
adj.method <- methodlist[[2]]
pmat[ltri]<-p.adjust(pmat[ltri], method = adj.method)
pmat[utri]<-t(pmat)[utri]
rownames(pmat)<-colnames(A)
colnames(pmat)<-colnames(A)
# Keep only correlations with adjusted p-value <=thresh
diag(cm)<-0
cm[pmat>thresh]<-0
}
if(method=="EBICglasso"){
corm.ebicglasso <- methodlist[[2]]
tun.ebicglasso <- methodlist[[3]]
correls<-cor(A,method=corm.ebicglasso)
cm<-EBICglasso(correls,n=dim(A)[1],gamma=tun.ebicglasso)
# Keep only correlations with p-value <=thresh; NOT NECESSARY FOR EBICGLASSO, AS VARIABLE SELECTION IS PERFORMED
diag(cm)<-0
#cm[correls$p.value>thresh]<-0
}
output<-cm
return(output)
}
###compute score for original unpermuted raw data
adj.A<-create.adjacency.matrix(A,methodlist=methodlist,thresh=thresh)
adj.B<-create.adjacency.matrix(B,methodlist=methodlist,thresh=thresh)
value.orig<-score.funct(adj.A,adj.B)
if(paired==FALSE){
D<-rbind(A,B)
#####function to create permutations from raw data
create.permut.unpaired<-function(seedex){
set.seed(seedex)
s<-sample(nrow(D),replace=FALSE)
D.new<-D[s,]
A.new<-D.new[1:nrow(A),]
B.new<-D.new[(nrow(A)+1):(nrow(D.new)),]
output<-list(A.new,B.new)
return(output)
}
##create permutations for raw data
shuffle <- lapply(1:permnum, create.permut.unpaired)
}
if(paired==TRUE){
#####function to create permutations from raw data
create.permut.paired<-function(seedex){
set.seed(seedex)
s<-sample(c("A","B"),nrow(A),replace=TRUE)
A.new<-rbind(A[s=="A",],B[s=="B",])
B.new<-rbind(B[s=="A",],A[s=="B",])
output<-list(A.new,B.new)
return(output)
}
##create permutations for raw data
shuffle <- lapply(1:permnum, create.permut.paired)
}
##compute score for the permnum permuted data sets
value.perm<-rep(NA,permnum)
for (n in 1:permnum){
adj.A.perm<-create.adjacency.matrix(shuffle[[n]][[1]],methodlist=methodlist,thresh=thresh)
adj.B.perm<-create.adjacency.matrix(shuffle[[n]][[2]],methodlist=methodlist,thresh=thresh)
value.perm[n]<-score.funct(adj.A.perm,adj.B.perm)
}
###permutation pseudocount p-value
num.extr<-sum(value.perm>=value.orig)
pvalue.ecdf<-num.extr/permnum
pvalue.ecdf.pseudo<-(1+num.extr)/(permnum+1)
output<-list(adj.A,adj.B,value.orig,value.perm,pvalue.ecdf,pvalue.ecdf.pseudo)
names(output)<-c("adjancency.matrix.A","adjacency.matrix.B","test.statistic","test.statistics.perm","pvalue","pvalue.pseudocount")
return(output)
}
perm.test.nw(A = x1, B = x2, permnum = 10, methodlist = list("PCSpearman"), thresh = 0.05, score.funct = frobenius.metric)
devtools::document()
perm.test.nw(A = x1, B = x2, permnum = 10, methodlist = list("PCSpearman"), thresh = 0.05, score.funct = frobenius.metric)
#' @param thresh
#' @param score.funct the function used to compare the adjacency matrices A and B.
#' @param paried
#' @details
#' Details
#' @return Return
#' @examples
#' perm.test.nw(A = x1, B = x2, permnum = 10, methodlist = list("DistCorr"), thresh = 0.05, score.funct = frobenius.metric)
#' @export
#'
perm.test.nw<-function(A, B, permnum, methodlist, thresh, score.funct, paired=FALSE){
##function to create adjacency matrix corresponding to raw data
create.adjacency.matrix<-function(A,methodlist,thresh=0.05){
method <- methodlist[[1]]
if(method=="Spearman"){
correls<-rcorr(as.matrix(A),type="spearman")
cm<-correls$r
# Keep only correlations with p-value <=thresh
diag(cm)<-0
cm[correls$P>thresh]<-0
}
if(method=="PCSpearman"){
correls<-pcor(as.matrix(A),method="spearman")
cm<-correls$estimate
# Keep only correlations with p-value <=thresh
diag(cm)<-0
cm[correls$p.value>thresh]<-0
}
if(method=="Spearman.adj"){
correls<-rcorr(as.matrix(A),type="spearman")
cm<-correls$r
pmat<-correls$P
ltri<-lower.tri(pmat)
utri<-upper.tri(pmat)
adj.method <- methodlist[[2]]
pmat[ltri]<-p.adjust(pmat[ltri], method = adj.method)
pmat[utri]<-t(pmat)[utri]
# Keep only correlations with adjusted p-value <=thresh
diag(cm)<-0
cm[pmat>thresh]<-0
}
if(method=="PCSpearman.adj"){
correls<-pcor(as.matrix(A),method="spearman")
cm<-correls$estimate
pmat<-correls$p.value
ltri<-lower.tri(pmat)
utri<-upper.tri(pmat)
adj.method <- methodlist[[2]]
pmat[ltri]<-p.adjust(pmat[ltri], method = adj.method)
pmat[utri]<-t(pmat)[utri]
# Keep only correlations with adjusted p-value <=thresh
diag(cm)<-0
cm[pmat>0.05]<-0
}
if(method=="DistCorr"){
A<-as.matrix(A)
cm<-array(data=NA,dim=c(dim(A)[2],dim(A)[2]))
for(i in 1:dim(A)[2]){
for(j in 1:dim(A)[2]){
cm[i,j]<-dcor(A[,i],A[,j],index=1.0)
}}
rownames(cm)<-colnames(A)
colnames(cm)<-colnames(A)
##compute p-values based on 10000 permutations
pvals<-array(data=NA,dim=c(dim(A)[2],dim(A)[2]))
for(i in 1:dim(A)[2]){
for(j in 1:dim(A)[2]){
set.seed(24)
pvals[i,j]<-dcor.test(A[,i],A[,j],index=1.0,R=10000)$p.value
}}
rownames(pvals)<-colnames(A)
colnames(pvals)<-colnames(A)
# Keep only correlations with p-value <=thresh
diag(cm)<-0
cm[pvals>thresh]<-0
}
if(method=="DistCorr.adj"){
A<-as.matrix(A)
cm<-array(data=NA,dim=c(dim(A)[2],dim(A)[2]))
for(i in 1:dim(A)[2]){
for(j in 1:dim(A)[2]){
cm[i,j]<-dcor(A[,i],A[,j],index=1.0)
}}
rownames(cm)<-colnames(A)
colnames(cm)<-colnames(A)
##compute p-values based on 10000 permutations
pvals<-array(data=NA,dim=c(dim(A)[2],dim(A)[2]))
for(i in 1:dim(A)[2]){
for(j in 1:dim(A)[2]){
set.seed(24)
pvals[i,j]<-dcor.test(A[,i],A[,j],index=1.0,R=10000)$p.value
}}
rownames(pvals)<-colnames(A)
colnames(pvals)<-colnames(A)
pmat<-pvals
ltri<-lower.tri(pmat)
utri<-upper.tri(pmat)
adj.method <- methodlist[[2]]
pmat[ltri]<-p.adjust(pmat[ltri], method = adj.method)
pmat[utri]<-t(pmat)[utri]
rownames(pmat)<-colnames(A)
colnames(pmat)<-colnames(A)
# Keep only correlations with adjusted p-value <=thresh
diag(cm)<-0
cm[pmat>thresh]<-0
}
if(method=="EBICglasso"){
corm.ebicglasso <- methodlist[[2]]
tun.ebicglasso <- methodlist[[3]]
correls<-cor(A,method=corm.ebicglasso)
cm<-EBICglasso(correls,n=dim(A)[1],gamma=tun.ebicglasso)
# Keep only correlations with p-value <=thresh; NOT NECESSARY FOR EBICGLASSO, AS VARIABLE SELECTION IS PERFORMED
diag(cm)<-0
#cm[correls$p.value>thresh]<-0
}
output<-cm
return(output)
}
###compute score for original unpermuted raw data
adj.A<-create.adjacency.matrix(A,methodlist=methodlist,thresh=thresh)
adj.B<-create.adjacency.matrix(B,methodlist=methodlist,thresh=thresh)
value.orig<-score.funct(adj.A,adj.B)
if(paired==FALSE){
D<-rbind(A,B)
#####function to create permutations from raw data
create.permut.unpaired<-function(seedex){
set.seed(seedex)
s<-sample(nrow(D),replace=FALSE)
D.new<-D[s,]
A.new<-D.new[1:nrow(A),]
B.new<-D.new[(nrow(A)+1):(nrow(D.new)),]
output<-list(A.new,B.new)
return(output)
}
##create permutations for raw data
shuffle <- lapply(1:permnum, create.permut.unpaired)
}
if(paired==TRUE){
#####function to create permutations from raw data
create.permut.paired<-function(seedex){
set.seed(seedex)
s<-sample(c("A","B"),nrow(A),replace=TRUE)
A.new<-rbind(A[s=="A",],B[s=="B",])
B.new<-rbind(B[s=="A",],A[s=="B",])
output<-list(A.new,B.new)
return(output)
}
##create permutations for raw data
shuffle <- lapply(1:permnum, create.permut.paired)
}
##compute score for the permnum permuted data sets
value.perm<-rep(NA,permnum)
for (n in 1:permnum){
adj.A.perm<-create.adjacency.matrix(shuffle[[n]][[1]],methodlist=methodlist,thresh=thresh)
adj.B.perm<-create.adjacency.matrix(shuffle[[n]][[2]],methodlist=methodlist,thresh=thresh)
value.perm[n]<-score.funct(adj.A.perm,adj.B.perm)
}
###permutation pseudocount p-value
num.extr<-sum(value.perm>=value.orig)
pvalue.ecdf<-num.extr/permnum
pvalue.ecdf.pseudo<-(1+num.extr)/(permnum+1)
output<-list(adj.A,adj.B,value.orig,value.perm,pvalue.ecdf,pvalue.ecdf.pseudo)
names(output)<-c("adjancency.matrix.A","adjacency.matrix.B","test.statistic","test.statistics.perm","pvalue","pvalue.pseudocount")
return(output)
}
perm.test.nw(A = x1, B = x2, permnum = 10, methodlist = list("PCSpearman"), thresh = 0.05, score.funct = frobenius.metric)
devtools::document()
devtools::load_all()
perm.test.nw(A = x1, B = x2, permnum = 10, methodlist = list("PCSpearman"), thresh = 0.05, score.funct = frobenius.metric)
perm.test.nw(A = x1, B = x2, permnum = 10, methodlist = list("DistCorr"), thresh = 0.05, score.funct = frobenius.metric)
perm.test.nw(A = x1, B = x2, permnum = 10, methodlist = list("DistCorr.adj"), thresh = 0.05, score.funct = frobenius.metric)
